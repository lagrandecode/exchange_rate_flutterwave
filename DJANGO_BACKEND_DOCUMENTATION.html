<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>DJANGO_BACKEND_DOCUMENTATION</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@5/github-markdown.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="django-backend-architecture-documentation">Django Backend Architecture Documentation</h1>
<h2 id="exchange-rate-flutterwave-application">Exchange Rate Flutterwave Application</h2>
<hr />
<h2 id="table-of-contents">Table of Contents</h2>
<ol type="1">
<li><a href="#overview">Overview</a></li>
<li><a href="#project-structure">Project Structure</a></li>
<li><a href="#core-components-explained">Core Components Explained</a>
<ul>
<li><a href="#backend-configuration">Backend Configuration</a></li>
<li><a href="#rates-app-components">Rates App Components</a></li>
<li><a href="#websocket-architecture">WebSocket Architecture</a></li>
<li><a href="#background-tasks">Background Tasks</a></li>
</ul></li>
<li><a href="#data-flow">Data Flow</a></li>
<li><a href="#key-technologies">Key Technologies</a></li>
</ol>
<hr />
<h2 id="overview">Overview</h2>
<p>This Django backend serves as a real-time exchange rate API that: - Fetches exchange rates from Flutterwave API - Caches rates in Redis for fast access - Stores rates in SQLite database for persistence - Broadcasts rate updates via WebSockets in real-time - Provides REST API endpoints for rate queries</p>
<p>The architecture is designed for <strong>instant response times</strong> with no loading spinners, using a multi-layer caching strategy and real-time updates.</p>
<hr />
<h2 id="project-structure">Project Structure</h2>
<pre><code>server/
├── backend/              # Main Django project configuration
│   ├── settings.py      # Django settings and configuration
│   ├── asgi.py          # ASGI application (WebSocket + HTTP)
│   ├── urls.py          # Root URL routing
│   └── wsgi.py          # WSGI application (traditional HTTP)
│
├── rates/               # Main application for exchange rates
│   ├── models.py        # Database models (ExchangeRate)
│   ├── views.py         # REST API endpoints
│   ├── services.py      # Business logic (Flutterwave API calls)
│   ├── cache.py         # Redis caching utilities
│   ├── consumers.py     # WebSocket consumers (real-time updates)
│   ├── routing.py       # WebSocket URL routing
│   ├── urls.py          # REST API URL patterns
│   └── management/
│       └── commands/
│           └── poll_rates.py  # Background rate polling command
│
├── manage.py            # Django management script
├── requirements.txt     # Python dependencies
└── db.sqlite3          # SQLite database file</code></pre>
<hr />
<h2 id="core-components-explained">Core Components Explained</h2>
<h3 id="backend-configuration">Backend Configuration</h3>
<h4 id="backendsettings.py"><code>backend/settings.py</code></h4>
<p><strong>Purpose</strong>: Central configuration file for the entire Django project.</p>
<p><strong>Key Responsibilities</strong>: - <strong>INSTALLED_APPS</strong>: Registers all Django apps including <code>rates</code>, <code>channels</code>, <code>rest_framework</code>, <code>corsheaders</code> - <strong>ASGI_APPLICATION</strong>: Points to <code>backend.asgi.application</code> to enable WebSocket support - <strong>CHANNEL_LAYERS</strong>: Configures Redis as the channel layer for WebSocket communication - <strong>CACHES</strong>: Configures Redis as the caching backend (different Redis DB from channels) - <strong>DATABASES</strong>: Configures SQLite as the database - <strong>CORS_ALLOW_ALL_ORIGINS</strong>: Allows cross-origin requests (for Flutter app) - <strong>FLUTTERWAVE_SECRET_KEY</strong>: Stores the API key for Flutterwave</p>
<p><strong>Why it matters</strong>: This file ties everything together. Without proper configuration here, WebSockets won’t work, caching won’t work, and the app won’t connect to external services.</p>
<hr />
<h4 id="backendasgi.py"><code>backend/asgi.py</code></h4>
<p><strong>Purpose</strong>: ASGI (Asynchronous Server Gateway Interface) application entry point.</p>
<p><strong>Key Responsibilities</strong>: - <strong>ProtocolTypeRouter</strong>: Routes HTTP and WebSocket traffic to different handlers - <strong>HTTP requests</strong>: Handled by traditional Django WSGI application - <strong>WebSocket connections</strong>: Routed to <code>rates.routing.websocket_urlpatterns</code> - <strong>AuthMiddlewareStack</strong>: Adds authentication support to WebSocket connections</p>
<p><strong>How it works</strong>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>application <span class="op">=</span> ProtocolTypeRouter({</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;http&quot;</span>: django_asgi_app,           <span class="co"># Regular HTTP requests</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;websocket&quot;</span>: AuthMiddlewareStack(   <span class="co"># WebSocket connections</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        URLRouter(rates.routing.websocket_urlpatterns)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>})</span></code></pre></div>
<p><strong>Why it matters</strong>: This is what enables real-time WebSocket communication. Without ASGI, you can only use traditional HTTP requests (which require polling).</p>
<hr />
<h4 id="backendurls.py"><code>backend/urls.py</code></h4>
<p><strong>Purpose</strong>: Root URL routing configuration.</p>
<p><strong>Key Responsibilities</strong>: - Maps <code>/admin/</code> to Django admin interface - Maps <code>/api/</code> to the <code>rates</code> app URLs</p>
<p><strong>URL Structure</strong>: - <code>/admin/</code> → Django admin - <code>/api/rates/</code> → Single rate endpoint - <code>/api/rates/all/</code> → All rates endpoint - <code>/ws/rates/</code> → WebSocket endpoint (defined in <code>rates/routing.py</code>)</p>
<hr />
<h3 id="rates-app-components">Rates App Components</h3>
<h4 id="ratesmodels.py"><code>rates/models.py</code></h4>
<p><strong>Purpose</strong>: Defines the database schema for storing exchange rates.</p>
<p><strong>Key Model: <code>ExchangeRate</code></strong></p>
<p><strong>Fields</strong>: - <code>source_currency</code>: 3-letter currency code (e.g., “USD”, “CAD”) - <code>destination_currency</code>: 3-letter currency code (e.g., “NGN”, “GHS”) - <code>rate</code>: The exchange rate (decimal with 8 decimal places) - <code>source_amount</code>: Amount in source currency - <code>destination_amount</code>: Amount in destination currency - <code>last_updated</code>: Timestamp of last update (auto-updated) - <code>created_at</code>: Timestamp of creation</p>
<p><strong>Database Features</strong>: - <strong>Unique constraint</strong>: One rate per currency pair (source + destination) - <strong>Indexes</strong>: Fast lookups on currency pairs and update times - <strong>Table name</strong>: <code>exchange_rates</code></p>
<p><strong>Why it matters</strong>: This is where all exchange rates are persistently stored. The database acts as a backup when Redis cache expires or is cleared.</p>
<hr />
<h4 id="ratesviews.py"><code>rates/views.py</code></h4>
<p><strong>Purpose</strong>: REST API endpoints that handle HTTP requests for exchange rates.</p>
<p><strong>Key Classes</strong>:</p>
<p><strong>1. <code>RatesView</code> (GET <code>/api/rates/</code>)</strong> - <strong>Purpose</strong>: Returns a single exchange rate for a currency pair - <strong>Query Parameters</strong>: <code>source_currency</code>, <code>destination_currency</code> - <strong>Response</strong>: Flutterwave-compatible JSON format</p>
<p><strong>How it works (Priority Order)</strong>: 1. <strong>Check Redis Cache</strong>: Fastest - returns immediately if found 2. <strong>Check Database</strong>: If not in cache, check SQLite database 3. <strong>Check if Stale</strong>: If database rate is older than 10 minutes, fetch fresh from Flutterwave 4. <strong>Fallback to Flutterwave</strong>: If not in database, fetch directly from Flutterwave API 5. <strong>Save &amp; Cache</strong>: Store new rates in both database and Redis</p>
<p><strong>2. <code>AllRatesView</code> (GET <code>/api/rates/all/</code>)</strong> - <strong>Purpose</strong>: Returns all exchange rates for a base currency - <strong>Query Parameters</strong>: <code>base_currency</code> (optional, defaults to “USD”) - <strong>Response</strong>: Dictionary of all currency pairs for the base currency</p>
<p><strong>Why it matters</strong>: These endpoints are what the Flutter app calls to get exchange rates. The multi-layer caching ensures instant responses.</p>
<hr />
<h4 id="ratesservices.py"><code>rates/services.py</code></h4>
<p><strong>Purpose</strong>: Business logic for interacting with Flutterwave API.</p>
<p><strong>Key Functions</strong>:</p>
<p><strong>1. <code>fetch_flutterwave_rate(source_currency, destination_currency)</code></strong> - <strong>Purpose</strong>: Makes HTTP request to Flutterwave API - <strong>Endpoint</strong>: <code>https://api.flutterwave.com/v3/transfers/rates</code> - <strong>Features</strong>: - Retry logic (3 attempts with exponential backoff) - 30-second timeout - Handles rate limiting (429 errors) - Returns raw Flutterwave JSON response</p>
<p><strong>2. <code>save_rate_to_db(source_currency, destination_currency, fw_response)</code></strong> - <strong>Purpose</strong>: Saves Flutterwave response to database - <strong>Uses</strong>: <code>update_or_create()</code> to avoid duplicates - <strong>Extracts</strong>: Rate, source amount, destination amount from Flutterwave response</p>
<p><strong>3. <code>to_backend_shape(resp)</code></strong> - <strong>Purpose</strong>: Ensures response matches Flutterwave format - <strong>Currently</strong>: Pass-through (returns response as-is)</p>
<p><strong>Why it matters</strong>: This is the only place in the codebase that directly talks to Flutterwave. All rate fetching goes through these functions, making it easy to modify API interaction logic.</p>
<hr />
<h4 id="ratescache.py"><code>rates/cache.py</code></h4>
<p><strong>Purpose</strong>: Redis caching utilities for fast rate lookups.</p>
<p><strong>Key Functions</strong>:</p>
<p><strong>1. <code>get_rate(source_currency, destination_currency)</code></strong> - <strong>Purpose</strong>: Retrieves rate from Redis cache - <strong>Returns</strong>: Cached rate data or <code>None</code> if not found - <strong>Cache Key Format</strong>: <code>fxrate:USD:NGN</code></p>
<p><strong>2. <code>set_rate(source_currency, destination_currency, payload, ttl_seconds)</code></strong> - <strong>Purpose</strong>: Stores rate in Redis cache - <strong>TTL</strong>: Time-to-live in seconds (default: 120 seconds = 2 minutes) - <strong>Why TTL</strong>: Ensures cache doesn’t hold stale data indefinitely</p>
<p><strong>Why it matters</strong>: Redis is in-memory, making it 100x faster than database queries. This is the first layer of caching that provides instant responses.</p>
<hr />
<h4 id="ratesurls.py"><code>rates/urls.py</code></h4>
<p><strong>Purpose</strong>: URL routing for the rates app REST API.</p>
<p><strong>URL Patterns</strong>: - <code>rates/</code> → <code>RatesView</code> (single rate) - <code>rates/all/</code> → <code>AllRatesView</code> (all rates)</p>
<p><strong>Full URLs</strong>: - <code>http://localhost:8000/api/rates/?source_currency=USD&amp;destination_currency=NGN</code> - <code>http://localhost:8000/api/rates/all/?base_currency=CAD</code></p>
<hr />
<h3 id="websocket-architecture">WebSocket Architecture</h3>
<h4 id="ratesrouting.py"><code>rates/routing.py</code></h4>
<p><strong>Purpose</strong>: Defines WebSocket URL patterns (similar to <code>urls.py</code> for HTTP).</p>
<p><strong>Key Responsibilities</strong>: - Maps WebSocket URL <code>/ws/rates/</code> to <code>RatesConsumer</code> - Uses Django’s <code>re_path</code> for regex-based routing</p>
<p><strong>WebSocket URL</strong>: <code>ws://localhost:8000/ws/rates/</code></p>
<p><strong>Why it matters</strong>: This is the routing layer for WebSocket connections. Without this, WebSocket clients can’t connect.</p>
<hr />
<h4 id="ratesconsumers.py"><code>rates/consumers.py</code></h4>
<p><strong>Purpose</strong>: Handles WebSocket connections and real-time rate updates.</p>
<p><strong>Key Class: <code>RatesConsumer</code></strong></p>
<p><strong>Methods</strong>:</p>
<p><strong>1. <code>connect()</code></strong> - <strong>When</strong>: Client connects to WebSocket - <strong>Actions</strong>: - Accepts the connection - Joins the <code>rates_updates</code> group (for broadcasting) - Sends all current rates immediately</p>
<p><strong>2. <code>disconnect(close_code)</code></strong> - <strong>When</strong>: Client disconnects - <strong>Actions</strong>: Removes client from <code>rates_updates</code> group</p>
<p><strong>3. <code>receive(text_data)</code></strong> - <strong>When</strong>: Client sends a message - <strong>Handles</strong>: - <code>get_all_rates</code>: Sends all rates - <code>get_rate</code>: Sends specific rate</p>
<p><strong>4. <code>rate_update(event)</code></strong> - <strong>When</strong>: Background poller updates a single rate - <strong>Action</strong>: Broadcasts the update to all connected clients</p>
<p><strong>5. <code>all_rates_update(event)</code></strong> - <strong>When</strong>: Background poller finishes updating all rates - <strong>Action</strong>: Notifies all clients that rates have been refreshed</p>
<p><strong>6. <code>get_all_rates_from_db()</code> / <code>get_rate_from_db()</code></strong> - <strong>Purpose</strong>: Async database queries to fetch rates - <strong>Uses</strong>: <code>@database_sync_to_async</code> decorator to run sync Django ORM queries in async context</p>
<p><strong>How Broadcasting Works</strong>: 1. Background poller (<code>poll_rates.py</code>) fetches new rate from Flutterwave 2. Poller calls <code>channel_layer.group_send('rates_updates', {...})</code> 3. All consumers in the <code>rates_updates</code> group receive the message 4. Each consumer’s <code>rate_update()</code> method is called 5. Consumer sends the update to its connected client via WebSocket</p>
<p><strong>Why it matters</strong>: This enables real-time updates without the Flutter app needing to poll. When rates change, all connected clients are instantly notified.</p>
<hr />
<h3 id="background-tasks">Background Tasks</h3>
<h4 id="ratesmanagementcommandspoll_rates.py"><code>rates/management/commands/poll_rates.py</code></h4>
<p><strong>Purpose</strong>: Background command that periodically fetches all exchange rates from Flutterwave.</p>
<p><strong>Key Responsibilities</strong>: - Fetches rates for all currency pairs every 10 minutes (configurable) - Saves rates to database - Caches rates in Redis - Broadcasts updates via WebSocket</p>
<p><strong>How to Run</strong>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> manage.py poll_rates                    <span class="co"># Runs continuously</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> manage.py poll_rates <span class="at">--once</span>             <span class="co"># Runs once and exits</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> manage.py poll_rates <span class="at">--interval</span> 300     <span class="co"># Runs every 5 minutes</span></span></code></pre></div>
<p><strong>Currency Pairs</strong>: - <strong>Source</strong>: USD, CAD, GBP, EUR (4 currencies) - <strong>Destination</strong>: XOF, XAF, EGP, ETB, GHS, KES, MAD, NGN, ZAR, UGX, ZMW (11 currencies) - <strong>Total Pairs</strong>: 4 × 11 = 44 pairs (excluding same-currency pairs)</p>
<p><strong>Workflow</strong>: 1. Loop through all source currencies 2. For each source, loop through all destination currencies 3. Fetch rate from Flutterwave API 4. Save to database 5. Cache in Redis (TTL = 2 × interval) 6. Broadcast update via WebSocket 7. Wait 0.5 seconds between requests (to avoid rate limiting) 8. After all pairs, broadcast “all rates updated” message 9. Sleep for interval (default: 10 minutes) 10. Repeat</p>
<p><strong>Why it matters</strong>: This keeps the database and cache fresh. Without this running, rates would become stale. The WebSocket broadcasting ensures clients get updates in real-time.</p>
<hr />
<h2 id="data-flow">Data Flow</h2>
<h3 id="initial-setup-flow">1. Initial Setup Flow</h3>
<pre><code>Background Poller (poll_rates.py)
    ↓
Fetches from Flutterwave API
    ↓
Saves to Database (SQLite)
    ↓
Caches in Redis
    ↓
Broadcasts via WebSocket
    ↓
Flutter App receives update</code></pre>
<h3 id="api-request-flow-get-apirates">2. API Request Flow (GET /api/rates/)</h3>
<pre><code>Flutter App Request
    ↓
RatesView.get()
    ↓
Check Redis Cache → Found? Return immediately ✓
    ↓ (Not found)
Check Database → Found? Check if stale
    ↓ (Stale or not found)
Fetch from Flutterwave API
    ↓
Save to Database
    ↓
Cache in Redis
    ↓
Return to Flutter App</code></pre>
<h3 id="real-time-update-flow">3. Real-Time Update Flow</h3>
<pre><code>Background Poller detects new rate
    ↓
Saves to Database
    ↓
Caches in Redis
    ↓
Broadcasts via Channel Layer (Redis)
    ↓
All WebSocket Consumers receive message
    ↓
Each Consumer sends to connected client
    ↓
Flutter App updates UI instantly</code></pre>
<hr />
<h2 id="key-technologies">Key Technologies</h2>
<h3 id="django-channels">Django Channels</h3>
<ul>
<li><strong>Purpose</strong>: Adds WebSocket support to Django</li>
<li><strong>Why</strong>: Enables real-time bidirectional communication</li>
<li><strong>Components</strong>: Channel Layers, Consumers, Routing</li>
</ul>
<h3 id="redis">Redis</h3>
<ul>
<li><strong>Purpose</strong>: Two uses:
<ol type="1">
<li><strong>Channel Layer</strong>: Routes WebSocket messages between processes</li>
<li><strong>Cache</strong>: Stores exchange rates for fast access</li>
</ol></li>
<li><strong>Why</strong>: In-memory storage is extremely fast (microseconds vs milliseconds)</li>
</ul>
<h3 id="django-rest-framework">Django REST Framework</h3>
<ul>
<li><strong>Purpose</strong>: Builds REST API endpoints</li>
<li><strong>Why</strong>: Provides standardized API responses and error handling</li>
</ul>
<h3 id="sqlite">SQLite</h3>
<ul>
<li><strong>Purpose</strong>: Persistent storage for exchange rates</li>
<li><strong>Why</strong>: Simple, file-based database perfect for development and small deployments</li>
</ul>
<h3 id="daphne">Daphne</h3>
<ul>
<li><strong>Purpose</strong>: ASGI server that runs the Django application</li>
<li><strong>Why</strong>: Required to handle both HTTP and WebSocket connections</li>
<li><strong>Alternative</strong>: Could use uvicorn, but Daphne is Django’s official ASGI server</li>
</ul>
<hr />
<h2 id="summary">Summary</h2>
<p>This Django backend is architected for <strong>speed and real-time updates</strong>:</p>
<ol type="1">
<li><strong>Multi-layer caching</strong>: Redis (fast) → Database (persistent) → Flutterwave (source of truth)</li>
<li><strong>Background polling</strong>: Keeps data fresh without blocking user requests</li>
<li><strong>WebSocket broadcasting</strong>: Pushes updates to clients instantly</li>
<li><strong>Stale rate detection</strong>: Automatically refreshes rates older than 10 minutes</li>
<li><strong>Graceful fallbacks</strong>: If cache fails, check database; if database fails, fetch from Flutterwave</li>
</ol>
<p>The result: <strong>Instant responses with no loading spinners</strong>, exactly like TapTap’s UX.</p>
<hr />
<h2 id="quick-reference">Quick Reference</h2>
<h3 id="start-the-server">Start the Server</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> server</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="bu">source</span> .venv/bin/activate</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ex">daphne</span> <span class="at">-b</span> 0.0.0.0 <span class="at">-p</span> 8000 backend.asgi:application</span></code></pre></div>
<h3 id="start-the-poller">Start the Poller</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> server</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="bu">source</span> .venv/bin/activate</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> manage.py poll_rates</span></code></pre></div>
<h3 id="test-websocket">Test WebSocket</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Connect to: ws://localhost:8000/ws/rates/</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Send: {&quot;type&quot;: &quot;get_all_rates&quot;}</span></span></code></pre></div>
<h3 id="test-rest-api">Test REST API</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">curl</span> <span class="st">&quot;http://localhost:8000/api/rates/?source_currency=USD&amp;destination_currency=NGN&quot;</span></span></code></pre></div>
<hr />
<p><strong>Document Version</strong>: 1.0<br />
<strong>Last Updated</strong>: 2024<br />
<strong>Author</strong>: Django Backend Documentation</p>
</body>
</html>
